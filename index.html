<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Drunk GPS Simulator</title>
    <link id="favicon" rel="shortcut icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuMTczbp9jAAAAdklEQVQ4T6WMUQ6AMAhDvf+l0S15BDrGNH68UNrCZWa/WI3H6lj6LpoSVJ0Uok/EJ8lEv6F8UEGukC1BhCeUNZszmjuOD8ZSMTJyNDteWcCDKnONoUW8Hd7rDsg68vLh2LtqpFCgS2dONXaMXJl+LKA74rGZXTdcBFXH/ciWAAAAAABJRU5ErkJggg==">
    <meta name="description" content="Simulate a drunk person tracked by GPS all around the world.">
    <meta name="author" content="Daniel Geymayer">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
      * {
        box-sizing: border-box;
      }
      body {
        font-family: Arial, Helvetica, sans-serif;
        background-color: #ddd;
        padding: 0;
        margin: 0;
      }
      main {
        background-color: #fff;
        max-width: 400px;
        margin: 0 auto;
        padding: 20px;
        box-shadow: 0 1px 8px rgba(0,0,0,0.3);
      }
      h1 {
        font-size: 21px;
        font-weight: normal;
        text-transform: uppercase;
        text-align: center;
        margin-top: 0;
        letter-spacing: 1px;
      }
      table tr td {
        padding-bottom: 10px;
      }
      table tr td:first-child {
        text-align: right;
        padding-right: 5px;
      }
      table tr td:last-child {
        text-align: left;
        padding-left: 5px;
      }
      label {
        font-size: 14px;
      }
      input, textarea, select {
        padding: 5px 5px;
      }
      input, textarea, button, canvas {
        border-radius: 3px;
        border: 1px solid #ccc;
        margin: 0;
      }
      textarea {
        font-family: monospace;
      }
      .responsiveness {
        width: 100%;
        max-width: 100%;
      }
      input {
        width: 130px;
      }
      input[type=range] {
        margin-top: 6px;
      }
      input:focus {
        border-color: rgb(13, 129, 242);
      }
      button {
        border: 2px solid rgb(13, 129, 242);
        padding: 8px 15px;
        font-size: 18px;
        cursor: pointer;
        background-color: rgba(30, 144, 255, 0.9);
        color: white;
      }
      button:hover {
        background-color: rgba(30, 144, 255, 0.8);
      }
      button:active {
        background-color: rgba(30, 144, 255, 1.0);
      }
      #gpsTrackCsvData {
        display: none;
        height: 100px;
      }
      #gpsTrackCanvas {
        display: none;
        border: 1px solid #ccc;
        transform: scale(1, -1);
        background-color: lightgreen;
        margin: 20px 0 10px;
      }
    </style>
  </head>
  <body>
    <main>
      <h1>Drunk GPS Simulator</h1>
      <form onsubmit="return generateGpsTrack()">
        <table class="responsiveness">
          <tr>
            <td><label for="startingPointField">Starting point</label></td>
            <td>
              <select id="startingPointField" autocomplete="off">
                <!-- TODO: Add "<i>Custom</i> option to allow entering your own lat/lon values -->
                <option value="52.371860,4.895861">Amsterdam, Netherlands</option>
                <option value="51.208147,3.224801">Bruges, Belgium</option>
                <option value="47.071952,15.439605">Graz, Austria</option>
                <option value="0.0,0.0">Null Island, Atlantic Ocean</option>
                <option value="42.430420,19.259364">Podgorica, Montenegro</option>
              </select>
            </td>
          </tr>
          <tr>
            <td><label for="numPointsField">Distance</label></td>
            <td>
              <select id="numPointsField" autocomplete="off">
                <!-- TODO: Add "<i>Custom</i> option to allow entering a custom amount of point values -->
                <option value="2">Some meters (2 points)</option>
                <option value="3">~100 m</option>
                <option value="5">~200 m</option>
                <option value="10">~500 m</option>
                <option value="100">~5 km</option>
                <option value="300" selected>~15 km</option>
                <option value="1000">Long to drive</option>
                <option value="10000">Very long to drive</option>
                <option value="100000">Small country</option>
                <!-- TODO: Enhance the path finding algorithm before enabling this: -->
                <!--<option value="500000">Amsterdam to Wales</option>
<option value="1000000">Million points</option>
<option value="1000000000">Billion points</option>-->
              </select>
            </td>
          </tr>
          <tr>
            <td><label for="maxAngleDiffField">Drunkeness</label></td>
            <!-- TODO: Enhance the path finding algorithm before setting min="0" for the range slider: -->
            <td><input type="range" id="maxAngleDiffField" value="90" min="1" max="360" step="1" autocomplete="off"></td>
          </tr>
        </table>
        <button type="submit" class="responsiveness">Stumble around</button>
      </form>
      <canvas id="gpsTrackCanvas" class="responsiveness" width="400" height="400"></canvas>
      <textarea id="gpsTrackCsvData" class="responsiveness" oninput="drawCsvTextOnCanvas()" autocomplete="off"></textarea>
    </main>

    <script>
      // --------------
      // Pure functions
      // --------------
      function min(numbers) {
        return Math.min.apply(null, numbers);
      }

      function max(numbers) {
        return Math.max.apply(null, numbers);
      }

      function calculateAngleBetweenGeoCoordinates(p1, p2) {
        let bearing = Math.atan2(p2.lat - p1.lat, p2.lon - p1.lon) * 180 / Math.PI;
        bearing = (bearing + 360) % 360;
        bearing = 360 - bearing;

        return bearing;
      }

      function isValidNextGeoCoordinate(p1, p2, p3, maxAngleDiff) {
        const angleOld = calculateAngleBetweenGeoCoordinates(p1, p2);
        const angleNew = calculateAngleBetweenGeoCoordinates(p2, p3);
        const diff = Math.abs(angleNew - angleOld) % 360;

        return diff <= (maxAngleDiff / 2);
      }

      function generateRandomNumber(min, max) {
        return Math.random() * (max - min) + min;
      }

      function generateNewGeoCoordinate(oldGeoCoordinate, minOffset, maxOffset) {
        const newGeoCoordinate = {
          lat: oldGeoCoordinate.lat + generateRandomNumber(minOffset, maxOffset),
          lon: oldGeoCoordinate.lon + generateRandomNumber(minOffset, maxOffset)
        };

        return newGeoCoordinate;
      }

      function geoCoordinatesToString(geoCoordinates, decimalPlaces) {
        return geoCoordinates
          .map(geoCoordinate => ({lat: geoCoordinate.lat.toFixed(decimalPlaces), lon: geoCoordinate.lon.toFixed(decimalPlaces)}));
      }

      function geoCoordinatesAsStringToNumeric(geoCoordinatesAsString) {
        return geoCoordinatesAsString
          .map(geoCoordinateAsString => ({lat: parseFloat(geoCoordinateAsString.lat), lon: parseFloat(geoCoordinateAsString.lon)}));
      }

      function buildCsvText(geoCoordinatesAsString) {
        return geoCoordinatesAsString
          .map(geoCoordinateAsString => [geoCoordinateAsString.lat, geoCoordinateAsString.lon].join(','))
          .join('\n');
      }

      function generateCanvasPoints(geoCoordinates, canvasWidth) {
        const latitudes = geoCoordinates.map(geoCoordinate => geoCoordinate.lat);
        const longitudes = geoCoordinates.map(geoCoordinate => geoCoordinate.lon);
        const minLat = min(latitudes);
        const maxLat = max(latitudes);
        const minLon = min(longitudes);
        const maxLon = max(longitudes);
        const factor = canvasWidth / Math.max((maxLat - minLat), (maxLon - minLon));

        const canvasPoints = geoCoordinates.map(geoCoordinate => {
          const x = (geoCoordinate.lon - minLon) * factor;
          const y = (geoCoordinate.lat - minLat) * factor;
          return {x: parseInt(x, 10), y: parseInt(y, 10)};
        });

        return canvasPoints;
      }

      // ----------
      // UI helpers
      // ----------
      const ctx = gpsTrackCanvas.getContext('2d');

      function drawGeoCoordinatesOnCanvas(geoCoordinates) {
        const canvasPoints = generateCanvasPoints(geoCoordinates, gpsTrackCanvas.width);

        ctx.beginPath();
        ctx.clearRect(0, 0, gpsTrackCanvas.width, gpsTrackCanvas.height);
        canvasPoints.forEach(point => {
          ctx.lineTo(point.x, point.y);
        });
        ctx.stroke();
      }

      function generateGeoCoordinates() {
        const minOffset = -0.0005;
        const maxOffset = 0.0005;
        const startingPointArray = startingPointField.value.split(',');
        const numPoints = parseInt(numPointsField.value, 10);
        const maxAngleDiff = parseFloat(maxAngleDiffField.value);

        const startGeoCoordinate = {lat: parseFloat(startingPointArray[0]), lon: parseFloat(startingPointArray[1])};
        const geoCoordinates = [startGeoCoordinate];
        geoCoordinates.push(generateNewGeoCoordinate(startGeoCoordinate, minOffset, maxOffset));
        const initialPointsLength = geoCoordinates.length;

        for (let i = 0; i < (numPoints - initialPointsLength); i++) {
          const lastGeoCoordinate = geoCoordinates[geoCoordinates.length - 1];
          const secondLastGeoCoordinate = geoCoordinates[geoCoordinates.length - 2];

          // TODO: Implement a better path finding algorithm (no guessing):
          while (true) {
            const potentialNextGeoCoordinate = generateNewGeoCoordinate(lastGeoCoordinate, minOffset, maxOffset);
            if (!isValidNextGeoCoordinate(secondLastGeoCoordinate, lastGeoCoordinate, potentialNextGeoCoordinate, maxAngleDiff)) {
              continue;
            }
            geoCoordinates.push(potentialNextGeoCoordinate);
            break;
          }
        }

        return geoCoordinates;
      }

      // ---------
      // UI events
      // ---------
      const geoCoordinatesDecimalPlaces = 6;

      function generateGpsTrack() {
        gpsTrackCanvas.style.display = 'block';
        gpsTrackCsvData.style.display = 'block';

        const geoCoordinates = generateGeoCoordinates();
        const geoCoordinatesAsString = geoCoordinatesToString(geoCoordinates, geoCoordinatesDecimalPlaces);

        gpsTrackCsvData.value = buildCsvText(geoCoordinatesAsString);

        const geoCoordinatesRounded = geoCoordinatesAsStringToNumeric(geoCoordinatesAsString);
        drawGeoCoordinatesOnCanvas(geoCoordinatesRounded);

        return false;
      }

      function drawCsvTextOnCanvas() {
        const geoCoordinatesAsString = gpsTrackCsvData.value.split('\n').map(line => {
          const latLonArray = line.split(',');
          return {lat: latLonArray[0], lon: latLonArray[1]};
        });
        const geoCoordinates = geoCoordinatesAsStringToNumeric(geoCoordinatesAsString);

        drawGeoCoordinatesOnCanvas(geoCoordinates);

        return false;
      }
    </script>
  </body>
</html>
